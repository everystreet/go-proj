// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 06 Dec 2019 15:08:31 UTC.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package cproj

/*
#cgo LDFLAGS: -lproj
#include "proj.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *PJ_AREA) Ref() *C.PJ_AREA {
	if x == nil {
		return nil
	}
	return (*C.PJ_AREA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_AREA) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_AREARef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_AREARef(ref unsafe.Pointer) *PJ_AREA {
	return (*PJ_AREA)(ref)
}

// NewPJ_AREA allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_AREA() *PJ_AREA {
	return (*PJ_AREA)(allocPJ_AREAMemory(1))
}

// allocPJ_AREAMemory allocates memory for type C.PJ_AREA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_AREAMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_AREAValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_AREAValue = unsafe.Sizeof([1]C.PJ_AREA{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_AREA) PassRef() *C.PJ_AREA {
	if x == nil {
		x = (*PJ_AREA)(allocPJ_AREAMemory(1))
	}
	return (*C.PJ_AREA)(unsafe.Pointer(x))
}

// allocPJ_FACTORSMemory allocates memory for type C.PJ_FACTORS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_FACTORSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_FACTORSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_FACTORSValue = unsafe.Sizeof([1]C.PJ_FACTORS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_FACTORS) Ref() *C.PJ_FACTORS {
	if x == nil {
		return nil
	}
	return x.ref24ee504e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_FACTORS) Free() {
	if x != nil && x.allocs24ee504e != nil {
		x.allocs24ee504e.(*cgoAllocMap).Free()
		x.ref24ee504e = nil
	}
}

// NewPJ_FACTORSRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_FACTORSRef(ref unsafe.Pointer) *PJ_FACTORS {
	if ref == nil {
		return nil
	}
	obj := new(PJ_FACTORS)
	obj.ref24ee504e = (*C.PJ_FACTORS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_FACTORS) PassRef() (*C.PJ_FACTORS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24ee504e != nil {
		return x.ref24ee504e, nil
	}
	mem24ee504e := allocPJ_FACTORSMemory(1)
	ref24ee504e := (*C.PJ_FACTORS)(mem24ee504e)
	allocs24ee504e := new(cgoAllocMap)
	allocs24ee504e.Add(mem24ee504e)

	var cmeridional_scale_allocs *cgoAllocMap
	ref24ee504e.meridional_scale, cmeridional_scale_allocs = (C.double)(x.meridional_scale), cgoAllocsUnknown
	allocs24ee504e.Borrow(cmeridional_scale_allocs)

	var cparallel_scale_allocs *cgoAllocMap
	ref24ee504e.parallel_scale, cparallel_scale_allocs = (C.double)(x.parallel_scale), cgoAllocsUnknown
	allocs24ee504e.Borrow(cparallel_scale_allocs)

	var careal_scale_allocs *cgoAllocMap
	ref24ee504e.areal_scale, careal_scale_allocs = (C.double)(x.areal_scale), cgoAllocsUnknown
	allocs24ee504e.Borrow(careal_scale_allocs)

	var cangular_distortion_allocs *cgoAllocMap
	ref24ee504e.angular_distortion, cangular_distortion_allocs = (C.double)(x.angular_distortion), cgoAllocsUnknown
	allocs24ee504e.Borrow(cangular_distortion_allocs)

	var cmeridian_parallel_angle_allocs *cgoAllocMap
	ref24ee504e.meridian_parallel_angle, cmeridian_parallel_angle_allocs = (C.double)(x.meridian_parallel_angle), cgoAllocsUnknown
	allocs24ee504e.Borrow(cmeridian_parallel_angle_allocs)

	var cmeridian_convergence_allocs *cgoAllocMap
	ref24ee504e.meridian_convergence, cmeridian_convergence_allocs = (C.double)(x.meridian_convergence), cgoAllocsUnknown
	allocs24ee504e.Borrow(cmeridian_convergence_allocs)

	var ctissot_semimajor_allocs *cgoAllocMap
	ref24ee504e.tissot_semimajor, ctissot_semimajor_allocs = (C.double)(x.tissot_semimajor), cgoAllocsUnknown
	allocs24ee504e.Borrow(ctissot_semimajor_allocs)

	var ctissot_semiminor_allocs *cgoAllocMap
	ref24ee504e.tissot_semiminor, ctissot_semiminor_allocs = (C.double)(x.tissot_semiminor), cgoAllocsUnknown
	allocs24ee504e.Borrow(ctissot_semiminor_allocs)

	var cdx_dlam_allocs *cgoAllocMap
	ref24ee504e.dx_dlam, cdx_dlam_allocs = (C.double)(x.dx_dlam), cgoAllocsUnknown
	allocs24ee504e.Borrow(cdx_dlam_allocs)

	var cdx_dphi_allocs *cgoAllocMap
	ref24ee504e.dx_dphi, cdx_dphi_allocs = (C.double)(x.dx_dphi), cgoAllocsUnknown
	allocs24ee504e.Borrow(cdx_dphi_allocs)

	var cdy_dlam_allocs *cgoAllocMap
	ref24ee504e.dy_dlam, cdy_dlam_allocs = (C.double)(x.dy_dlam), cgoAllocsUnknown
	allocs24ee504e.Borrow(cdy_dlam_allocs)

	var cdy_dphi_allocs *cgoAllocMap
	ref24ee504e.dy_dphi, cdy_dphi_allocs = (C.double)(x.dy_dphi), cgoAllocsUnknown
	allocs24ee504e.Borrow(cdy_dphi_allocs)

	x.ref24ee504e = ref24ee504e
	x.allocs24ee504e = allocs24ee504e
	return ref24ee504e, allocs24ee504e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_FACTORS) PassValue() (C.PJ_FACTORS, *cgoAllocMap) {
	if x.ref24ee504e != nil {
		return *x.ref24ee504e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_FACTORS) Deref() {
	if x.ref24ee504e == nil {
		return
	}
	x.meridional_scale = (float64)(x.ref24ee504e.meridional_scale)
	x.parallel_scale = (float64)(x.ref24ee504e.parallel_scale)
	x.areal_scale = (float64)(x.ref24ee504e.areal_scale)
	x.angular_distortion = (float64)(x.ref24ee504e.angular_distortion)
	x.meridian_parallel_angle = (float64)(x.ref24ee504e.meridian_parallel_angle)
	x.meridian_convergence = (float64)(x.ref24ee504e.meridian_convergence)
	x.tissot_semimajor = (float64)(x.ref24ee504e.tissot_semimajor)
	x.tissot_semiminor = (float64)(x.ref24ee504e.tissot_semiminor)
	x.dx_dlam = (float64)(x.ref24ee504e.dx_dlam)
	x.dx_dphi = (float64)(x.ref24ee504e.dx_dphi)
	x.dy_dlam = (float64)(x.ref24ee504e.dy_dlam)
	x.dy_dphi = (float64)(x.ref24ee504e.dy_dphi)
}

// Ref returns a reference to C object as it is.
func (x *PJ) Ref() *C.PJ {
	if x == nil {
		return nil
	}
	return (*C.PJ)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJRef converts the C object reference into a raw struct reference without wrapping.
func NewPJRef(ref unsafe.Pointer) *PJ {
	return (*PJ)(ref)
}

// NewPJ allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ() *PJ {
	return (*PJ)(allocPJMemory(1))
}

// allocPJMemory allocates memory for type C.PJ in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJValue = unsafe.Sizeof([1]C.PJ{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ) PassRef() *C.PJ {
	if x == nil {
		x = (*PJ)(allocPJMemory(1))
	}
	return (*C.PJ)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PJ_INFO) Ref() *C.PJ_INFO {
	if x == nil {
		return nil
	}
	return (*C.PJ_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_INFO) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_INFORef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_INFORef(ref unsafe.Pointer) *PJ_INFO {
	return (*PJ_INFO)(ref)
}

// NewPJ_INFO allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_INFO() *PJ_INFO {
	return (*PJ_INFO)(allocPJ_INFOMemory(1))
}

// allocPJ_INFOMemory allocates memory for type C.PJ_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_INFOValue = unsafe.Sizeof([1]C.PJ_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_INFO) PassRef() *C.PJ_INFO {
	if x == nil {
		x = (*PJ_INFO)(allocPJ_INFOMemory(1))
	}
	return (*C.PJ_INFO)(unsafe.Pointer(x))
}

// allocPJ_PROJ_INFOMemory allocates memory for type C.PJ_PROJ_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_PROJ_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_PROJ_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_PROJ_INFOValue = unsafe.Sizeof([1]C.PJ_PROJ_INFO{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_PROJ_INFO) Ref() *C.PJ_PROJ_INFO {
	if x == nil {
		return nil
	}
	return x.ref249cc27f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_PROJ_INFO) Free() {
	if x != nil && x.allocs249cc27f != nil {
		x.allocs249cc27f.(*cgoAllocMap).Free()
		x.ref249cc27f = nil
	}
}

// NewPJ_PROJ_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_PROJ_INFORef(ref unsafe.Pointer) *PJ_PROJ_INFO {
	if ref == nil {
		return nil
	}
	obj := new(PJ_PROJ_INFO)
	obj.ref249cc27f = (*C.PJ_PROJ_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_PROJ_INFO) PassRef() (*C.PJ_PROJ_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref249cc27f != nil {
		return x.ref249cc27f, nil
	}
	mem249cc27f := allocPJ_PROJ_INFOMemory(1)
	ref249cc27f := (*C.PJ_PROJ_INFO)(mem249cc27f)
	allocs249cc27f := new(cgoAllocMap)
	allocs249cc27f.Add(mem249cc27f)

	var cid_allocs *cgoAllocMap
	ref249cc27f.id, cid_allocs = unpackPCharString(x.id)
	allocs249cc27f.Borrow(cid_allocs)

	var cdescription_allocs *cgoAllocMap
	ref249cc27f.description, cdescription_allocs = unpackPCharString(x.description)
	allocs249cc27f.Borrow(cdescription_allocs)

	var cdefinition_allocs *cgoAllocMap
	ref249cc27f.definition, cdefinition_allocs = unpackPCharString(x.definition)
	allocs249cc27f.Borrow(cdefinition_allocs)

	var chas_inverse_allocs *cgoAllocMap
	ref249cc27f.has_inverse, chas_inverse_allocs = (C.int)(x.has_inverse), cgoAllocsUnknown
	allocs249cc27f.Borrow(chas_inverse_allocs)

	var caccuracy_allocs *cgoAllocMap
	ref249cc27f.accuracy, caccuracy_allocs = (C.double)(x.accuracy), cgoAllocsUnknown
	allocs249cc27f.Borrow(caccuracy_allocs)

	x.ref249cc27f = ref249cc27f
	x.allocs249cc27f = allocs249cc27f
	return ref249cc27f, allocs249cc27f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_PROJ_INFO) PassValue() (C.PJ_PROJ_INFO, *cgoAllocMap) {
	if x.ref249cc27f != nil {
		return *x.ref249cc27f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_PROJ_INFO) Deref() {
	if x.ref249cc27f == nil {
		return
	}
	x.id = packPCharString(x.ref249cc27f.id)
	x.description = packPCharString(x.ref249cc27f.description)
	x.definition = packPCharString(x.ref249cc27f.definition)
	x.has_inverse = (int32)(x.ref249cc27f.has_inverse)
	x.accuracy = (float64)(x.ref249cc27f.accuracy)
}

// allocPJ_GRID_INFOMemory allocates memory for type C.PJ_GRID_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_GRID_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_GRID_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_GRID_INFOValue = unsafe.Sizeof([1]C.PJ_GRID_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_GRID_INFO) Ref() *C.PJ_GRID_INFO {
	if x == nil {
		return nil
	}
	return x.refb5e7b98d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_GRID_INFO) Free() {
	if x != nil && x.allocsb5e7b98d != nil {
		x.allocsb5e7b98d.(*cgoAllocMap).Free()
		x.refb5e7b98d = nil
	}
}

// NewPJ_GRID_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_GRID_INFORef(ref unsafe.Pointer) *PJ_GRID_INFO {
	if ref == nil {
		return nil
	}
	obj := new(PJ_GRID_INFO)
	obj.refb5e7b98d = (*C.PJ_GRID_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_GRID_INFO) PassRef() (*C.PJ_GRID_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb5e7b98d != nil {
		return x.refb5e7b98d, nil
	}
	memb5e7b98d := allocPJ_GRID_INFOMemory(1)
	refb5e7b98d := (*C.PJ_GRID_INFO)(memb5e7b98d)
	allocsb5e7b98d := new(cgoAllocMap)
	allocsb5e7b98d.Add(memb5e7b98d)

	var cgridname_allocs *cgoAllocMap
	refb5e7b98d.gridname, cgridname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.gridname)), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(cgridname_allocs)

	var cfilename_allocs *cgoAllocMap
	refb5e7b98d.filename, cfilename_allocs = *(*[260]C.char)(unsafe.Pointer(&x.filename)), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(cfilename_allocs)

	var cformat_allocs *cgoAllocMap
	refb5e7b98d.format, cformat_allocs = *(*[8]C.char)(unsafe.Pointer(&x.format)), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(cformat_allocs)

	var cn_lon_allocs *cgoAllocMap
	refb5e7b98d.n_lon, cn_lon_allocs = (C.int)(x.n_lon), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(cn_lon_allocs)

	var cn_lat_allocs *cgoAllocMap
	refb5e7b98d.n_lat, cn_lat_allocs = (C.int)(x.n_lat), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(cn_lat_allocs)

	var ccs_lon_allocs *cgoAllocMap
	refb5e7b98d.cs_lon, ccs_lon_allocs = (C.double)(x.cs_lon), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(ccs_lon_allocs)

	var ccs_lat_allocs *cgoAllocMap
	refb5e7b98d.cs_lat, ccs_lat_allocs = (C.double)(x.cs_lat), cgoAllocsUnknown
	allocsb5e7b98d.Borrow(ccs_lat_allocs)

	x.refb5e7b98d = refb5e7b98d
	x.allocsb5e7b98d = allocsb5e7b98d
	return refb5e7b98d, allocsb5e7b98d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_GRID_INFO) PassValue() (C.PJ_GRID_INFO, *cgoAllocMap) {
	if x.refb5e7b98d != nil {
		return *x.refb5e7b98d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_GRID_INFO) Deref() {
	if x.refb5e7b98d == nil {
		return
	}
	x.gridname = *(*[32]byte)(unsafe.Pointer(&x.refb5e7b98d.gridname))
	x.filename = *(*[260]byte)(unsafe.Pointer(&x.refb5e7b98d.filename))
	x.format = *(*[8]byte)(unsafe.Pointer(&x.refb5e7b98d.format))
	x.n_lon = (int32)(x.refb5e7b98d.n_lon)
	x.n_lat = (int32)(x.refb5e7b98d.n_lat)
	x.cs_lon = (float64)(x.refb5e7b98d.cs_lon)
	x.cs_lat = (float64)(x.refb5e7b98d.cs_lat)
}

// allocPJ_INIT_INFOMemory allocates memory for type C.PJ_INIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_INIT_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_INIT_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_INIT_INFOValue = unsafe.Sizeof([1]C.PJ_INIT_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_INIT_INFO) Ref() *C.PJ_INIT_INFO {
	if x == nil {
		return nil
	}
	return x.ref55e744e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_INIT_INFO) Free() {
	if x != nil && x.allocs55e744e0 != nil {
		x.allocs55e744e0.(*cgoAllocMap).Free()
		x.ref55e744e0 = nil
	}
}

// NewPJ_INIT_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_INIT_INFORef(ref unsafe.Pointer) *PJ_INIT_INFO {
	if ref == nil {
		return nil
	}
	obj := new(PJ_INIT_INFO)
	obj.ref55e744e0 = (*C.PJ_INIT_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_INIT_INFO) PassRef() (*C.PJ_INIT_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55e744e0 != nil {
		return x.ref55e744e0, nil
	}
	mem55e744e0 := allocPJ_INIT_INFOMemory(1)
	ref55e744e0 := (*C.PJ_INIT_INFO)(mem55e744e0)
	allocs55e744e0 := new(cgoAllocMap)
	allocs55e744e0.Add(mem55e744e0)

	var cname_allocs *cgoAllocMap
	ref55e744e0.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.name)), cgoAllocsUnknown
	allocs55e744e0.Borrow(cname_allocs)

	var cfilename_allocs *cgoAllocMap
	ref55e744e0.filename, cfilename_allocs = *(*[260]C.char)(unsafe.Pointer(&x.filename)), cgoAllocsUnknown
	allocs55e744e0.Borrow(cfilename_allocs)

	var cversion_allocs *cgoAllocMap
	ref55e744e0.version, cversion_allocs = *(*[32]C.char)(unsafe.Pointer(&x.version)), cgoAllocsUnknown
	allocs55e744e0.Borrow(cversion_allocs)

	var corigin_allocs *cgoAllocMap
	ref55e744e0.origin, corigin_allocs = *(*[32]C.char)(unsafe.Pointer(&x.origin)), cgoAllocsUnknown
	allocs55e744e0.Borrow(corigin_allocs)

	var clastupdate_allocs *cgoAllocMap
	ref55e744e0.lastupdate, clastupdate_allocs = *(*[16]C.char)(unsafe.Pointer(&x.lastupdate)), cgoAllocsUnknown
	allocs55e744e0.Borrow(clastupdate_allocs)

	x.ref55e744e0 = ref55e744e0
	x.allocs55e744e0 = allocs55e744e0
	return ref55e744e0, allocs55e744e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_INIT_INFO) PassValue() (C.PJ_INIT_INFO, *cgoAllocMap) {
	if x.ref55e744e0 != nil {
		return *x.ref55e744e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_INIT_INFO) Deref() {
	if x.ref55e744e0 == nil {
		return
	}
	x.name = *(*[32]byte)(unsafe.Pointer(&x.ref55e744e0.name))
	x.filename = *(*[260]byte)(unsafe.Pointer(&x.ref55e744e0.filename))
	x.version = *(*[32]byte)(unsafe.Pointer(&x.ref55e744e0.version))
	x.origin = *(*[32]byte)(unsafe.Pointer(&x.ref55e744e0.origin))
	x.lastupdate = *(*[16]byte)(unsafe.Pointer(&x.ref55e744e0.lastupdate))
}

// Ref returns a reference to C object as it is.
func (x *PJ_OPERATIONS) Ref() *C.PJ_OPERATIONS {
	if x == nil {
		return nil
	}
	return (*C.PJ_OPERATIONS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_OPERATIONS) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_OPERATIONSRef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_OPERATIONSRef(ref unsafe.Pointer) *PJ_OPERATIONS {
	return (*PJ_OPERATIONS)(ref)
}

// NewPJ_OPERATIONS allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_OPERATIONS() *PJ_OPERATIONS {
	return (*PJ_OPERATIONS)(allocPJ_OPERATIONSMemory(1))
}

// allocPJ_OPERATIONSMemory allocates memory for type C.PJ_OPERATIONS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_OPERATIONSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_OPERATIONSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_OPERATIONSValue = unsafe.Sizeof([1]C.PJ_OPERATIONS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_OPERATIONS) PassRef() *C.PJ_OPERATIONS {
	if x == nil {
		x = (*PJ_OPERATIONS)(allocPJ_OPERATIONSMemory(1))
	}
	return (*C.PJ_OPERATIONS)(unsafe.Pointer(x))
}

// allocPJ_ELLPSMemory allocates memory for type C.PJ_ELLPS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_ELLPSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_ELLPSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_ELLPSValue = unsafe.Sizeof([1]C.PJ_ELLPS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_ELLPS) Ref() *C.PJ_ELLPS {
	if x == nil {
		return nil
	}
	return x.ref5d2fa5b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_ELLPS) Free() {
	if x != nil && x.allocs5d2fa5b8 != nil {
		x.allocs5d2fa5b8.(*cgoAllocMap).Free()
		x.ref5d2fa5b8 = nil
	}
}

// NewPJ_ELLPSRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_ELLPSRef(ref unsafe.Pointer) *PJ_ELLPS {
	if ref == nil {
		return nil
	}
	obj := new(PJ_ELLPS)
	obj.ref5d2fa5b8 = (*C.PJ_ELLPS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_ELLPS) PassRef() (*C.PJ_ELLPS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5d2fa5b8 != nil {
		return x.ref5d2fa5b8, nil
	}
	mem5d2fa5b8 := allocPJ_ELLPSMemory(1)
	ref5d2fa5b8 := (*C.PJ_ELLPS)(mem5d2fa5b8)
	allocs5d2fa5b8 := new(cgoAllocMap)
	allocs5d2fa5b8.Add(mem5d2fa5b8)

	var cid_allocs *cgoAllocMap
	ref5d2fa5b8.id, cid_allocs = unpackPCharString(x.id)
	allocs5d2fa5b8.Borrow(cid_allocs)

	var cmajor_allocs *cgoAllocMap
	ref5d2fa5b8.major, cmajor_allocs = unpackPCharString(x.major)
	allocs5d2fa5b8.Borrow(cmajor_allocs)

	var cell_allocs *cgoAllocMap
	ref5d2fa5b8.ell, cell_allocs = unpackPCharString(x.ell)
	allocs5d2fa5b8.Borrow(cell_allocs)

	var cname_allocs *cgoAllocMap
	ref5d2fa5b8.name, cname_allocs = unpackPCharString(x.name)
	allocs5d2fa5b8.Borrow(cname_allocs)

	x.ref5d2fa5b8 = ref5d2fa5b8
	x.allocs5d2fa5b8 = allocs5d2fa5b8
	return ref5d2fa5b8, allocs5d2fa5b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_ELLPS) PassValue() (C.PJ_ELLPS, *cgoAllocMap) {
	if x.ref5d2fa5b8 != nil {
		return *x.ref5d2fa5b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_ELLPS) Deref() {
	if x.ref5d2fa5b8 == nil {
		return
	}
	x.id = packPCharString(x.ref5d2fa5b8.id)
	x.major = packPCharString(x.ref5d2fa5b8.major)
	x.ell = packPCharString(x.ref5d2fa5b8.ell)
	x.name = packPCharString(x.ref5d2fa5b8.name)
}

// allocPJ_UNITSMemory allocates memory for type C.PJ_UNITS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_UNITSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_UNITSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_UNITSValue = unsafe.Sizeof([1]C.PJ_UNITS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_UNITS) Ref() *C.PJ_UNITS {
	if x == nil {
		return nil
	}
	return x.reff561fd5e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_UNITS) Free() {
	if x != nil && x.allocsf561fd5e != nil {
		x.allocsf561fd5e.(*cgoAllocMap).Free()
		x.reff561fd5e = nil
	}
}

// NewPJ_UNITSRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_UNITSRef(ref unsafe.Pointer) *PJ_UNITS {
	if ref == nil {
		return nil
	}
	obj := new(PJ_UNITS)
	obj.reff561fd5e = (*C.PJ_UNITS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_UNITS) PassRef() (*C.PJ_UNITS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff561fd5e != nil {
		return x.reff561fd5e, nil
	}
	memf561fd5e := allocPJ_UNITSMemory(1)
	reff561fd5e := (*C.PJ_UNITS)(memf561fd5e)
	allocsf561fd5e := new(cgoAllocMap)
	allocsf561fd5e.Add(memf561fd5e)

	var cid_allocs *cgoAllocMap
	reff561fd5e.id, cid_allocs = unpackPCharString(x.id)
	allocsf561fd5e.Borrow(cid_allocs)

	var cto_meter_allocs *cgoAllocMap
	reff561fd5e.to_meter, cto_meter_allocs = unpackPCharString(x.to_meter)
	allocsf561fd5e.Borrow(cto_meter_allocs)

	var cname_allocs *cgoAllocMap
	reff561fd5e.name, cname_allocs = unpackPCharString(x.name)
	allocsf561fd5e.Borrow(cname_allocs)

	var cfactor_allocs *cgoAllocMap
	reff561fd5e.factor, cfactor_allocs = (C.double)(x.factor), cgoAllocsUnknown
	allocsf561fd5e.Borrow(cfactor_allocs)

	x.reff561fd5e = reff561fd5e
	x.allocsf561fd5e = allocsf561fd5e
	return reff561fd5e, allocsf561fd5e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_UNITS) PassValue() (C.PJ_UNITS, *cgoAllocMap) {
	if x.reff561fd5e != nil {
		return *x.reff561fd5e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_UNITS) Deref() {
	if x.reff561fd5e == nil {
		return
	}
	x.id = packPCharString(x.reff561fd5e.id)
	x.to_meter = packPCharString(x.reff561fd5e.to_meter)
	x.name = packPCharString(x.reff561fd5e.name)
	x.factor = (float64)(x.reff561fd5e.factor)
}

// allocPJ_PRIME_MERIDIANSMemory allocates memory for type C.PJ_PRIME_MERIDIANS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_PRIME_MERIDIANSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_PRIME_MERIDIANSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_PRIME_MERIDIANSValue = unsafe.Sizeof([1]C.PJ_PRIME_MERIDIANS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PJ_PRIME_MERIDIANS) Ref() *C.PJ_PRIME_MERIDIANS {
	if x == nil {
		return nil
	}
	return x.ref9dd6bf1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PJ_PRIME_MERIDIANS) Free() {
	if x != nil && x.allocs9dd6bf1e != nil {
		x.allocs9dd6bf1e.(*cgoAllocMap).Free()
		x.ref9dd6bf1e = nil
	}
}

// NewPJ_PRIME_MERIDIANSRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPJ_PRIME_MERIDIANSRef(ref unsafe.Pointer) *PJ_PRIME_MERIDIANS {
	if ref == nil {
		return nil
	}
	obj := new(PJ_PRIME_MERIDIANS)
	obj.ref9dd6bf1e = (*C.PJ_PRIME_MERIDIANS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PJ_PRIME_MERIDIANS) PassRef() (*C.PJ_PRIME_MERIDIANS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9dd6bf1e != nil {
		return x.ref9dd6bf1e, nil
	}
	mem9dd6bf1e := allocPJ_PRIME_MERIDIANSMemory(1)
	ref9dd6bf1e := (*C.PJ_PRIME_MERIDIANS)(mem9dd6bf1e)
	allocs9dd6bf1e := new(cgoAllocMap)
	allocs9dd6bf1e.Add(mem9dd6bf1e)

	var cid_allocs *cgoAllocMap
	ref9dd6bf1e.id, cid_allocs = unpackPCharString(x.id)
	allocs9dd6bf1e.Borrow(cid_allocs)

	var cdefn_allocs *cgoAllocMap
	ref9dd6bf1e.defn, cdefn_allocs = unpackPCharString(x.defn)
	allocs9dd6bf1e.Borrow(cdefn_allocs)

	x.ref9dd6bf1e = ref9dd6bf1e
	x.allocs9dd6bf1e = allocs9dd6bf1e
	return ref9dd6bf1e, allocs9dd6bf1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PJ_PRIME_MERIDIANS) PassValue() (C.PJ_PRIME_MERIDIANS, *cgoAllocMap) {
	if x.ref9dd6bf1e != nil {
		return *x.ref9dd6bf1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PJ_PRIME_MERIDIANS) Deref() {
	if x.ref9dd6bf1e == nil {
		return
	}
	x.id = packPCharString(x.ref9dd6bf1e.id)
	x.defn = packPCharString(x.ref9dd6bf1e.defn)
}

// Ref returns a reference to C object as it is.
func (x *PJ_CONTEXT) Ref() *C.PJ_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.PJ_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_CONTEXT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_CONTEXTRef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_CONTEXTRef(ref unsafe.Pointer) *PJ_CONTEXT {
	return (*PJ_CONTEXT)(ref)
}

// NewPJ_CONTEXT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_CONTEXT() *PJ_CONTEXT {
	return (*PJ_CONTEXT)(allocPJ_CONTEXTMemory(1))
}

// allocPJ_CONTEXTMemory allocates memory for type C.PJ_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_CONTEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_CONTEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_CONTEXTValue = unsafe.Sizeof([1]C.PJ_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_CONTEXT) PassRef() *C.PJ_CONTEXT {
	if x == nil {
		x = (*PJ_CONTEXT)(allocPJ_CONTEXTMemory(1))
	}
	return (*C.PJ_CONTEXT)(unsafe.Pointer(x))
}

// allocPROJ_CRS_INFOMemory allocates memory for type C.PROJ_CRS_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPROJ_CRS_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPROJ_CRS_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPROJ_CRS_INFOValue = unsafe.Sizeof([1]C.PROJ_CRS_INFO{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PROJ_CRS_INFO) Ref() *C.PROJ_CRS_INFO {
	if x == nil {
		return nil
	}
	return x.ref48245dab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PROJ_CRS_INFO) Free() {
	if x != nil && x.allocs48245dab != nil {
		x.allocs48245dab.(*cgoAllocMap).Free()
		x.ref48245dab = nil
	}
}

// NewPROJ_CRS_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPROJ_CRS_INFORef(ref unsafe.Pointer) *PROJ_CRS_INFO {
	if ref == nil {
		return nil
	}
	obj := new(PROJ_CRS_INFO)
	obj.ref48245dab = (*C.PROJ_CRS_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PROJ_CRS_INFO) PassRef() (*C.PROJ_CRS_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48245dab != nil {
		return x.ref48245dab, nil
	}
	mem48245dab := allocPROJ_CRS_INFOMemory(1)
	ref48245dab := (*C.PROJ_CRS_INFO)(mem48245dab)
	allocs48245dab := new(cgoAllocMap)
	allocs48245dab.Add(mem48245dab)

	var cauth_name_allocs *cgoAllocMap
	ref48245dab.auth_name, cauth_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.auth_name)).Data)), cgoAllocsUnknown
	allocs48245dab.Borrow(cauth_name_allocs)

	var ccode_allocs *cgoAllocMap
	ref48245dab.code, ccode_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.code)).Data)), cgoAllocsUnknown
	allocs48245dab.Borrow(ccode_allocs)

	var cname_allocs *cgoAllocMap
	ref48245dab.name, cname_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.name)).Data)), cgoAllocsUnknown
	allocs48245dab.Borrow(cname_allocs)

	var c_type_allocs *cgoAllocMap
	ref48245dab._type, c_type_allocs = (C.PJ_TYPE)(x._type), cgoAllocsUnknown
	allocs48245dab.Borrow(c_type_allocs)

	var cdeprecated_allocs *cgoAllocMap
	ref48245dab.deprecated, cdeprecated_allocs = (C.int)(x.deprecated), cgoAllocsUnknown
	allocs48245dab.Borrow(cdeprecated_allocs)

	var cbbox_valid_allocs *cgoAllocMap
	ref48245dab.bbox_valid, cbbox_valid_allocs = (C.int)(x.bbox_valid), cgoAllocsUnknown
	allocs48245dab.Borrow(cbbox_valid_allocs)

	var cwest_lon_degree_allocs *cgoAllocMap
	ref48245dab.west_lon_degree, cwest_lon_degree_allocs = (C.double)(x.west_lon_degree), cgoAllocsUnknown
	allocs48245dab.Borrow(cwest_lon_degree_allocs)

	var csouth_lat_degree_allocs *cgoAllocMap
	ref48245dab.south_lat_degree, csouth_lat_degree_allocs = (C.double)(x.south_lat_degree), cgoAllocsUnknown
	allocs48245dab.Borrow(csouth_lat_degree_allocs)

	var ceast_lon_degree_allocs *cgoAllocMap
	ref48245dab.east_lon_degree, ceast_lon_degree_allocs = (C.double)(x.east_lon_degree), cgoAllocsUnknown
	allocs48245dab.Borrow(ceast_lon_degree_allocs)

	var cnorth_lat_degree_allocs *cgoAllocMap
	ref48245dab.north_lat_degree, cnorth_lat_degree_allocs = (C.double)(x.north_lat_degree), cgoAllocsUnknown
	allocs48245dab.Borrow(cnorth_lat_degree_allocs)

	var carea_name_allocs *cgoAllocMap
	ref48245dab.area_name, carea_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.area_name)).Data)), cgoAllocsUnknown
	allocs48245dab.Borrow(carea_name_allocs)

	var cprojection_method_name_allocs *cgoAllocMap
	ref48245dab.projection_method_name, cprojection_method_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.projection_method_name)).Data)), cgoAllocsUnknown
	allocs48245dab.Borrow(cprojection_method_name_allocs)

	x.ref48245dab = ref48245dab
	x.allocs48245dab = allocs48245dab
	return ref48245dab, allocs48245dab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PROJ_CRS_INFO) PassValue() (C.PROJ_CRS_INFO, *cgoAllocMap) {
	if x.ref48245dab != nil {
		return *x.ref48245dab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PROJ_CRS_INFO) Deref() {
	if x.ref48245dab == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.auth_name))
	hxfc4425b.Data = unsafe.Pointer(x.ref48245dab.auth_name)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.code))
	hxf95e7c8.Data = unsafe.Pointer(x.ref48245dab.code)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.name))
	hxff2234b.Data = unsafe.Pointer(x.ref48245dab.name)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x._type = (PJ_TYPE)(x.ref48245dab._type)
	x.deprecated = (int32)(x.ref48245dab.deprecated)
	x.bbox_valid = (int32)(x.ref48245dab.bbox_valid)
	x.west_lon_degree = (float64)(x.ref48245dab.west_lon_degree)
	x.south_lat_degree = (float64)(x.ref48245dab.south_lat_degree)
	x.east_lon_degree = (float64)(x.ref48245dab.east_lon_degree)
	x.north_lat_degree = (float64)(x.ref48245dab.north_lat_degree)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.area_name))
	hxff73280.Data = unsafe.Pointer(x.ref48245dab.area_name)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.projection_method_name))
	hxfa9955c.Data = unsafe.Pointer(x.ref48245dab.projection_method_name)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocPROJ_CRS_LIST_PARAMETERSMemory allocates memory for type C.PROJ_CRS_LIST_PARAMETERS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPROJ_CRS_LIST_PARAMETERSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPROJ_CRS_LIST_PARAMETERSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPROJ_CRS_LIST_PARAMETERSValue = unsafe.Sizeof([1]C.PROJ_CRS_LIST_PARAMETERS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PROJ_CRS_LIST_PARAMETERS) Ref() *C.PROJ_CRS_LIST_PARAMETERS {
	if x == nil {
		return nil
	}
	return x.ref577cd7ca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PROJ_CRS_LIST_PARAMETERS) Free() {
	if x != nil && x.allocs577cd7ca != nil {
		x.allocs577cd7ca.(*cgoAllocMap).Free()
		x.ref577cd7ca = nil
	}
}

// NewPROJ_CRS_LIST_PARAMETERSRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPROJ_CRS_LIST_PARAMETERSRef(ref unsafe.Pointer) *PROJ_CRS_LIST_PARAMETERS {
	if ref == nil {
		return nil
	}
	obj := new(PROJ_CRS_LIST_PARAMETERS)
	obj.ref577cd7ca = (*C.PROJ_CRS_LIST_PARAMETERS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PROJ_CRS_LIST_PARAMETERS) PassRef() (*C.PROJ_CRS_LIST_PARAMETERS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref577cd7ca != nil {
		return x.ref577cd7ca, nil
	}
	mem577cd7ca := allocPROJ_CRS_LIST_PARAMETERSMemory(1)
	ref577cd7ca := (*C.PROJ_CRS_LIST_PARAMETERS)(mem577cd7ca)
	allocs577cd7ca := new(cgoAllocMap)
	allocs577cd7ca.Add(mem577cd7ca)

	var ctypes_allocs *cgoAllocMap
	ref577cd7ca.types, ctypes_allocs = (*C.PJ_TYPE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.types)).Data)), cgoAllocsUnknown
	allocs577cd7ca.Borrow(ctypes_allocs)

	var ctypesCount_allocs *cgoAllocMap
	ref577cd7ca.typesCount, ctypesCount_allocs = (C.size_t)(x.typesCount), cgoAllocsUnknown
	allocs577cd7ca.Borrow(ctypesCount_allocs)

	var ccrs_area_of_use_contains_bbox_allocs *cgoAllocMap
	ref577cd7ca.crs_area_of_use_contains_bbox, ccrs_area_of_use_contains_bbox_allocs = (C.int)(x.crs_area_of_use_contains_bbox), cgoAllocsUnknown
	allocs577cd7ca.Borrow(ccrs_area_of_use_contains_bbox_allocs)

	var cbbox_valid_allocs *cgoAllocMap
	ref577cd7ca.bbox_valid, cbbox_valid_allocs = (C.int)(x.bbox_valid), cgoAllocsUnknown
	allocs577cd7ca.Borrow(cbbox_valid_allocs)

	var cwest_lon_degree_allocs *cgoAllocMap
	ref577cd7ca.west_lon_degree, cwest_lon_degree_allocs = (C.double)(x.west_lon_degree), cgoAllocsUnknown
	allocs577cd7ca.Borrow(cwest_lon_degree_allocs)

	var csouth_lat_degree_allocs *cgoAllocMap
	ref577cd7ca.south_lat_degree, csouth_lat_degree_allocs = (C.double)(x.south_lat_degree), cgoAllocsUnknown
	allocs577cd7ca.Borrow(csouth_lat_degree_allocs)

	var ceast_lon_degree_allocs *cgoAllocMap
	ref577cd7ca.east_lon_degree, ceast_lon_degree_allocs = (C.double)(x.east_lon_degree), cgoAllocsUnknown
	allocs577cd7ca.Borrow(ceast_lon_degree_allocs)

	var cnorth_lat_degree_allocs *cgoAllocMap
	ref577cd7ca.north_lat_degree, cnorth_lat_degree_allocs = (C.double)(x.north_lat_degree), cgoAllocsUnknown
	allocs577cd7ca.Borrow(cnorth_lat_degree_allocs)

	var callow_deprecated_allocs *cgoAllocMap
	ref577cd7ca.allow_deprecated, callow_deprecated_allocs = (C.int)(x.allow_deprecated), cgoAllocsUnknown
	allocs577cd7ca.Borrow(callow_deprecated_allocs)

	x.ref577cd7ca = ref577cd7ca
	x.allocs577cd7ca = allocs577cd7ca
	return ref577cd7ca, allocs577cd7ca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PROJ_CRS_LIST_PARAMETERS) PassValue() (C.PROJ_CRS_LIST_PARAMETERS, *cgoAllocMap) {
	if x.ref577cd7ca != nil {
		return *x.ref577cd7ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PROJ_CRS_LIST_PARAMETERS) Deref() {
	if x.ref577cd7ca == nil {
		return
	}
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.types))
	hxfa3f05c.Data = unsafe.Pointer(x.ref577cd7ca.types)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.typesCount = (uint)(x.ref577cd7ca.typesCount)
	x.crs_area_of_use_contains_bbox = (int32)(x.ref577cd7ca.crs_area_of_use_contains_bbox)
	x.bbox_valid = (int32)(x.ref577cd7ca.bbox_valid)
	x.west_lon_degree = (float64)(x.ref577cd7ca.west_lon_degree)
	x.south_lat_degree = (float64)(x.ref577cd7ca.south_lat_degree)
	x.east_lon_degree = (float64)(x.ref577cd7ca.east_lon_degree)
	x.north_lat_degree = (float64)(x.ref577cd7ca.north_lat_degree)
	x.allow_deprecated = (int32)(x.ref577cd7ca.allow_deprecated)
}

// Ref returns a reference to C object as it is.
func (x *PJ_OBJ_LIST) Ref() *C.PJ_OBJ_LIST {
	if x == nil {
		return nil
	}
	return (*C.PJ_OBJ_LIST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_OBJ_LIST) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_OBJ_LISTRef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_OBJ_LISTRef(ref unsafe.Pointer) *PJ_OBJ_LIST {
	return (*PJ_OBJ_LIST)(ref)
}

// NewPJ_OBJ_LIST allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_OBJ_LIST() *PJ_OBJ_LIST {
	return (*PJ_OBJ_LIST)(allocPJ_OBJ_LISTMemory(1))
}

// allocPJ_OBJ_LISTMemory allocates memory for type C.PJ_OBJ_LIST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_OBJ_LISTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_OBJ_LISTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_OBJ_LISTValue = unsafe.Sizeof([1]C.PJ_OBJ_LIST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_OBJ_LIST) PassRef() *C.PJ_OBJ_LIST {
	if x == nil {
		x = (*PJ_OBJ_LIST)(allocPJ_OBJ_LISTMemory(1))
	}
	return (*C.PJ_OBJ_LIST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PJ_OPERATION_FACTORY_CONTEXT) Ref() *C.PJ_OPERATION_FACTORY_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.PJ_OPERATION_FACTORY_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PJ_OPERATION_FACTORY_CONTEXT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPJ_OPERATION_FACTORY_CONTEXTRef converts the C object reference into a raw struct reference without wrapping.
func NewPJ_OPERATION_FACTORY_CONTEXTRef(ref unsafe.Pointer) *PJ_OPERATION_FACTORY_CONTEXT {
	return (*PJ_OPERATION_FACTORY_CONTEXT)(ref)
}

// NewPJ_OPERATION_FACTORY_CONTEXT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPJ_OPERATION_FACTORY_CONTEXT() *PJ_OPERATION_FACTORY_CONTEXT {
	return (*PJ_OPERATION_FACTORY_CONTEXT)(allocPJ_OPERATION_FACTORY_CONTEXTMemory(1))
}

// allocPJ_OPERATION_FACTORY_CONTEXTMemory allocates memory for type C.PJ_OPERATION_FACTORY_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPJ_OPERATION_FACTORY_CONTEXTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPJ_OPERATION_FACTORY_CONTEXTValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPJ_OPERATION_FACTORY_CONTEXTValue = unsafe.Sizeof([1]C.PJ_OPERATION_FACTORY_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PJ_OPERATION_FACTORY_CONTEXT) PassRef() *C.PJ_OPERATION_FACTORY_CONTEXT {
	if x == nil {
		x = (*PJ_OPERATION_FACTORY_CONTEXT)(allocPJ_OPERATION_FACTORY_CONTEXTMemory(1))
	}
	return (*C.PJ_OPERATION_FACTORY_CONTEXT)(unsafe.Pointer(x))
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = unsafe.Pointer(ptr1)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// allocPIntMemory allocates memory for type *C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPIntValue = unsafe.Sizeof([1]*C.int{})

// unpackArgSSInt32 transforms a sliced Go data structure into plain C format.
func unpackArgSSInt32(x [][]int32) (unpacked **C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.int)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.int)(h.Data)
	return
}

// packSSInt32 reads sliced Go data structure out from plain C format.
func packSSInt32(v [][]int32, ptr0 **C.int) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.int)(unsafe.Pointer(ptr0)))[i0]
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf69fe70.Data = unsafe.Pointer(ptr1)
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?
	}
}

// unpackArgSPROJ_CRS_LIST_PARAMETERS transforms a sliced Go data structure into plain C format.
func unpackArgSPROJ_CRS_LIST_PARAMETERS(x []PROJ_CRS_LIST_PARAMETERS) (unpacked *C.PROJ_CRS_LIST_PARAMETERS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.PROJ_CRS_LIST_PARAMETERS) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPROJ_CRS_LIST_PARAMETERSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.PROJ_CRS_LIST_PARAMETERS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.PROJ_CRS_LIST_PARAMETERS)(h.Data)
	return
}

// packSPROJ_CRS_LIST_PARAMETERS reads sliced Go data structure out from plain C format.
func packSPROJ_CRS_LIST_PARAMETERS(v []PROJ_CRS_LIST_PARAMETERS, ptr0 *C.PROJ_CRS_LIST_PARAMETERS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPROJ_CRS_LIST_PARAMETERSValue]C.PROJ_CRS_LIST_PARAMETERS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPROJ_CRS_LIST_PARAMETERSRef(unsafe.Pointer(&ptr1))
	}
}

// packSPPROJ_CRS_INFO reads sliced Go data structure out from plain C format.
func packSPPROJ_CRS_INFO(v []*PROJ_CRS_INFO, ptr0 **C.PROJ_CRS_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PROJ_CRS_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewPROJ_CRS_INFORef(unsafe.Pointer(ptr1))
	}
}

// allocPPROJ_CRS_INFOMemory allocates memory for type *C.PROJ_CRS_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPROJ_CRS_INFOMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPROJ_CRS_INFOValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPROJ_CRS_INFOValue = unsafe.Sizeof([1]*C.PROJ_CRS_INFO{})

// unpackArgSSPROJ_CRS_INFO transforms a sliced Go data structure into plain C format.
func unpackArgSSPROJ_CRS_INFO(x [][]PROJ_CRS_INFO) (unpacked **C.PROJ_CRS_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.PROJ_CRS_INFO) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPROJ_CRS_INFOMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.PROJ_CRS_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPROJ_CRS_INFOMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.PROJ_CRS_INFO)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.PROJ_CRS_INFO)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.PROJ_CRS_INFO)(h.Data)
	return
}

// packSSPROJ_CRS_INFO reads sliced Go data structure out from plain C format.
func packSSPROJ_CRS_INFO(v [][]PROJ_CRS_INFO, ptr0 **C.PROJ_CRS_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.PROJ_CRS_INFO)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPROJ_CRS_INFOValue]C.PROJ_CRS_INFO)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPROJ_CRS_INFORef(unsafe.Pointer(&ptr2))
		}
	}
}
